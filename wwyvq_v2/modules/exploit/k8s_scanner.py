#!/usr/bin/env python3
"""
WWYVQ Framework v2 - Kubernetes Scanner
Author: wKayaa
Date: 2025-01-15

Module de scan et détection de clusters Kubernetes.
"""

import asyncio
import aiohttp
import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
import ssl


@dataclass
class KubernetesCluster:
    """Représentation d'un cluster Kubernetes détecté"""
    endpoint: str
    port: int
    version: Optional[str] = None
    status: str = "detected"
    api_accessible: bool = False
    authentication_required: bool = True
    services_exposed: List[str] = field(default_factory=list)
    vulnerabilities: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    discovered_at: datetime = field(default_factory=datetime.utcnow)


class KubernetesScanner:
    """
    Scanner de clusters Kubernetes
    
    Responsabilités:
    - Détection de clusters Kubernetes
    - Identification des services exposés
    - Reconnaissance des versions
    - Détection de vulnérabilités communes
    """
    
    def __init__(self, config_manager, logger):
        """
        Initialise le scanner Kubernetes
        
        Args:
            config_manager: Gestionnaire de configuration
            logger: Logger WWYVQ
        """
        self.config_manager = config_manager
        self.logger = logger
        self.discovered_clusters: List[KubernetesCluster] = []
        
        # Configuration des ports Kubernetes courants
        self.k8s_ports = [
            6443,  # API Server (TLS)
            8443,  # API Server (TLS alternative)
            8080,  # API Server (non-TLS, deprecated)
            10250, # Kubelet
            10255, # Kubelet (read-only)
            10256, # Kube-proxy
            2379,  # etcd
            2380,  # etcd peer
            9090,  # Prometheus
            9443,  # Webhook admission controllers
            8001,  # kubectl proxy
            8002   # kube-controller-manager
        ]
        
        # Signatures Kubernetes
        self.k8s_signatures = [
            "kubernetes",
            "api/v1",
            "apis/",
            "openapi/v2",
            "healthz",
            "readyz",
            "livez",
            "version",
            "metrics"
        ]
    
    async def scan_target(self, target: str, port: Optional[int] = None) -> List[KubernetesCluster]:
        """
        Scanne une cible pour détecter Kubernetes
        
        Args:
            target: Adresse IP ou hostname
            port: Port spécifique (optionnel)
            
        Returns:
            List[KubernetesCluster]: Clusters détectés
        """
        clusters = []
        
        # Ports à scanner
        ports_to_scan = [port] if port else self.k8s_ports
        
        # Configuration SSL permissive
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        connector = aiohttp.TCPConnector(
            ssl=ssl_context,
            limit=100,
            limit_per_host=20,
            keepalive_timeout=30
        )
        
        async with aiohttp.ClientSession(
            connector=connector,
            timeout=aiohttp.ClientTimeout(total=30)
        ) as session:
            
            # Scan des ports
            tasks = []
            for port_num in ports_to_scan:
                task = self._scan_port(session, target, port_num)
                tasks.append(task)
            
            # Exécution parallèle
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Traitement des résultats
            for result in results:
                if isinstance(result, KubernetesCluster):
                    clusters.append(result)
                    self.discovered_clusters.append(result)
                    
                    self.logger.info(
                        f"Kubernetes cluster detected: {result.endpoint}:{result.port}",
                        module="exploit.k8s_scanner",
                        target=target,
                        port=result.port
                    )
        
        return clusters
    
    async def _scan_port(self, session: aiohttp.ClientSession, target: str, port: int) -> Optional[KubernetesCluster]:
        """
        Scanne un port spécifique
        
        Args:
            session: Session HTTP
            target: Cible
            port: Port à scanner
            
        Returns:
            KubernetesCluster ou None
        """
        protocols = ['https', 'http']
        
        for protocol in protocols:
            url = f"{protocol}://{target}:{port}"
            
            try:
                # Test initial de connectivité
                async with session.get(url, timeout=10) as response:
                    
                    # Vérification de la réponse
                    if response.status in [200, 401, 403, 404]:
                        
                        # Vérification des signatures Kubernetes
                        if await self._is_kubernetes_service(session, url, response):
                            
                            cluster = KubernetesCluster(
                                endpoint=target,
                                port=port,
                                metadata={'protocol': protocol}
                            )
                            
                            # Enrichissement des informations
                            await self._enrich_cluster_info(session, cluster)
                            
                            return cluster
                    
            except Exception as e:
                # Log des erreurs uniquement en mode debug
                if self.config_manager.get_config().core.debug_mode:
                    self.logger.debug(
                        f"Scan failed for {url}: {e}",
                        module="exploit.k8s_scanner",
                        target=target,
                        port=port
                    )
        
        return None
    
    async def _is_kubernetes_service(self, session: aiohttp.ClientSession, base_url: str, response: aiohttp.ClientResponse) -> bool:
        """
        Vérifie si le service est Kubernetes
        
        Args:
            session: Session HTTP
            base_url: URL de base
            response: Réponse HTTP
            
        Returns:
            bool: True si c'est un service Kubernetes
        """
        # Vérification des headers
        headers = response.headers
        
        # Headers Kubernetes typiques
        k8s_headers = ['x-kubernetes-pf-flowschema-uid', 'x-kubernetes-pf-prioritylevel-uid']
        if any(header in headers for header in k8s_headers):
            return True
        
        # Vérification du contenu
        try:
            content = await response.text()
            
            # Signatures dans le contenu
            if any(sig in content.lower() for sig in self.k8s_signatures):
                return True
                
        except Exception:
            pass
        
        # Test des endpoints Kubernetes courants
        k8s_endpoints = [
            '/api/v1',
            '/apis',
            '/version',
            '/healthz',
            '/readyz',
            '/livez',
            '/openapi/v2'
        ]
        
        for endpoint in k8s_endpoints:
            try:
                test_url = f"{base_url}{endpoint}"
                async with session.get(test_url, timeout=5) as test_response:
                    if test_response.status in [200, 401, 403]:
                        return True
            except Exception:
                continue
        
        return False
    
    async def _enrich_cluster_info(self, session: aiohttp.ClientSession, cluster: KubernetesCluster):
        """
        Enrichit les informations du cluster
        
        Args:
            session: Session HTTP
            cluster: Cluster à enrichir
        """
        base_url = f"{cluster.metadata['protocol']}://{cluster.endpoint}:{cluster.port}"
        
        # Tentative de récupération de la version
        await self._get_cluster_version(session, base_url, cluster)
        
        # Détection des services exposés
        await self._detect_exposed_services(session, base_url, cluster)
        
        # Vérification de l'accès API
        await self._check_api_access(session, base_url, cluster)
        
        # Détection de vulnérabilités
        await self._detect_vulnerabilities(session, base_url, cluster)
    
    async def _get_cluster_version(self, session: aiohttp.ClientSession, base_url: str, cluster: KubernetesCluster):
        """Récupère la version du cluster"""
        version_endpoints = ['/version', '/api/v1/version']
        
        for endpoint in version_endpoints:
            try:
                url = f"{base_url}{endpoint}"
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        data = await response.json()
                        if 'gitVersion' in data:
                            cluster.version = data['gitVersion']
                            break
            except Exception:
                continue
    
    async def _detect_exposed_services(self, session: aiohttp.ClientSession, base_url: str, cluster: KubernetesCluster):
        """Détecte les services exposés"""
        services_endpoints = [
            '/api/v1/services',
            '/api/v1/namespaces/default/services',
            '/api/v1/namespaces/kube-system/services'
        ]
        
        for endpoint in services_endpoints:
            try:
                url = f"{base_url}{endpoint}"
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        data = await response.json()
                        if 'items' in data:
                            for item in data['items']:
                                if 'metadata' in item and 'name' in item['metadata']:
                                    service_name = item['metadata']['name']
                                    if service_name not in cluster.services_exposed:
                                        cluster.services_exposed.append(service_name)
            except Exception:
                continue
    
    async def _check_api_access(self, session: aiohttp.ClientSession, base_url: str, cluster: KubernetesCluster):
        """Vérifie l'accès à l'API"""
        api_endpoints = ['/api/v1', '/apis']
        
        for endpoint in api_endpoints:
            try:
                url = f"{base_url}{endpoint}"
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        cluster.api_accessible = True
                        cluster.authentication_required = False
                        break
                    elif response.status == 401:
                        cluster.api_accessible = True
                        cluster.authentication_required = True
                        break
            except Exception:
                continue
    
    async def _detect_vulnerabilities(self, session: aiohttp.ClientSession, base_url: str, cluster: KubernetesCluster):
        """Détecte les vulnérabilités communes"""
        
        # Vérification d'accès anonyme
        if not cluster.authentication_required:
            cluster.vulnerabilities.append("anonymous_access")
        
        # Vérification des endpoints sensibles
        sensitive_endpoints = [
            '/api/v1/secrets',
            '/api/v1/configmaps',
            '/api/v1/serviceaccounts',
            '/api/v1/pods',
            '/api/v1/namespaces/kube-system/secrets'
        ]
        
        for endpoint in sensitive_endpoints:
            try:
                url = f"{base_url}{endpoint}"
                async with session.get(url, timeout=5) as response:
                    if response.status == 200:
                        cluster.vulnerabilities.append(f"exposed_{endpoint.split('/')[-1]}")
            except Exception:
                continue
        
        # Vérification de la version
        if cluster.version:
            # Vérification de versions vulnérables connues
            vulnerable_versions = [
                "v1.0.", "v1.1.", "v1.2.", "v1.3.", "v1.4.", "v1.5.",
                "v1.6.", "v1.7.", "v1.8.", "v1.9.", "v1.10.", "v1.11."
            ]
            
            for vuln_version in vulnerable_versions:
                if vuln_version in cluster.version:
                    cluster.vulnerabilities.append("outdated_version")
                    break
    
    async def scan_multiple_targets(self, targets: List[str]) -> List[KubernetesCluster]:
        """
        Scanne plusieurs cibles
        
        Args:
            targets: Liste des cibles
            
        Returns:
            List[KubernetesCluster]: Tous les clusters détectés
        """
        all_clusters = []
        
        # Configuration de la concurrence
        config = self.config_manager.get_config()
        semaphore = asyncio.Semaphore(config.core.max_concurrent)
        
        async def scan_with_semaphore(target):
            async with semaphore:
                return await self.scan_target(target)
        
        # Création des tâches
        tasks = [scan_with_semaphore(target) for target in targets]
        
        # Exécution avec gestion des exceptions
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Traitement des résultats
        for result in results:
            if isinstance(result, list):
                all_clusters.extend(result)
            elif isinstance(result, Exception):
                self.logger.error(
                    f"Scan error: {result}",
                    module="exploit.k8s_scanner"
                )
        
        self.logger.info(
            f"Scan completed: {len(all_clusters)} clusters found across {len(targets)} targets",
            module="exploit.k8s_scanner",
            clusters_found=len(all_clusters)
        )
        
        return all_clusters
    
    def get_discovered_clusters(self) -> List[KubernetesCluster]:
        """
        Récupère tous les clusters découverts
        
        Returns:
            List[KubernetesCluster]: Clusters découverts
        """
        return self.discovered_clusters
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Récupère les statistiques du scanner
        
        Returns:
            Dict: Statistiques
        """
        total_clusters = len(self.discovered_clusters)
        accessible_clusters = sum(1 for c in self.discovered_clusters if c.api_accessible)
        vulnerable_clusters = sum(1 for c in self.discovered_clusters if c.vulnerabilities)
        
        return {
            'total_clusters': total_clusters,
            'accessible_clusters': accessible_clusters,
            'vulnerable_clusters': vulnerable_clusters,
            'versions_found': list(set(c.version for c in self.discovered_clusters if c.version)),
            'common_vulnerabilities': self._get_common_vulnerabilities()
        }
    
    def _get_common_vulnerabilities(self) -> Dict[str, int]:
        """Récupère les vulnérabilités communes"""
        vuln_counts = {}
        
        for cluster in self.discovered_clusters:
            for vuln in cluster.vulnerabilities:
                vuln_counts[vuln] = vuln_counts.get(vuln, 0) + 1
        
        return vuln_counts